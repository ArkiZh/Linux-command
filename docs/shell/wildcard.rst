Shell 通配符、元字符、转义符
###############################

说到 shell 通配符（wildcard），大家在使用时候会经常用到。下面是一个实例：

.. highlight:: none

::

    [chengmo@localhost ~/shell]$ ls
    a.txt  b.txt  c.old

    [chengmo@localhost ~/shell]$ ls *.txt
    a.txt  b.txt

    [chengmo@localhost ~/shell]$ ls d*.txt
    ls: 无法访问 d*.txt: 没有那个文件或目录

shell 通配符（wildcard）
*******************************

通配符是由 shell 处理的（不是由所涉及到命令语句处理的，其实我们在 shell 各个命令中也没有发现有这些通配符介绍），它只会出现在命令的“参数”里（它不用在命令名称里，也不用在操作符上）。当 shell 在“参数”中遇到了通配符时，shell 会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换（路径扩展）；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。

总之，通配符实际上就是一种 shell 实现的路径扩展功能。在通配符被处理后，shell 会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。

我们回过头分析上面命令吧：在第 2 个命令中，*.txt 实际是 shell 搜索文件，找到了符合条件的文件，命令会变成：ls a.txt b.txt，在执行 ls 时候传给它的是 a.txt b.txt。

而命令 3，d*.txt 由于当前目录下面没有这样的文件或目录，直接将“d*.txt”作为 ls 参数，传给了 ls。这个时候“*”只是一个普通的 ls 参数而已，已经失去了它通配意义。由于找不到文件，所以会出现：无法访问的提示！

了解了 shell 通配符，我们来看一下，shell 常见通配符有那些：

==================   ==============================   ========================
字符                  含义                               实例
==================   ==============================   ========================
*                     匹配 0 或多个字符                   a*b 匹配 aabcb、axyzb、a012b、ab ...
?                     匹配任意一个字符                    a?b 匹配 aab、abb、acb、a0b ...
[list]                匹配 list 中的任意单一字符          a[xyz]b 匹配 axb、ayb、azb
[!list]               匹配除 list 中的任意单一字符        a[!0-9]b 匹配 axb、aab、a-b ...
[a-f]                 匹配 a~f 中的任意单一字符           a[a-f]b 匹配 aab、abb、acb ...
{abc,xyz, ...}        匹配大括号内的任意一个字符串         a{abc,xyz,123}b匹配 aabcb、axyzb、a123b
==================   ==============================   ========================

需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为 shell 特殊代号字符就行。而且涉及的只有，`` * ? [] {} ``这几种。

shell 元字符（特殊字符 Meta）
*******************************

shell 除了有通配符之外，由 shell 负责预先先解析后，将处理结果传给命令行之外，shell 还有一系列自己的其他特殊字符。

=====   ==========
字符      说明
=====   ==========
IFS       由 <space> 或 <tab> 或 <enter> 三者之一组成（常用 space）
CR        由 <enter> 产生
=         设定变量
$         作变量或运算替换（不要与 shell prompt 搞混了）
>         输出重定向 stdout。 *
<         输入重定向 stdin。 *
|         命令管道。 *
&         重导向 file descriptor，或将命令置于背境执行。 *
( )       将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 *
{ }       将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。
;         在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 *
&&        在前一个命令结束时，若返回值为 true，继续执行下一个命令。 *
||        在前一个命令结束时，若返回值为 false，继续执行下一个命令。 *
!         执行 history 列表中的命令。*
=====   ==========

加入“*”都是作用在命令名直接。可以看到 shell 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。

以下是 man bash 得到的英文解析：

metacharacter
              A character that, when unquoted, separates words.  One of the following:
              |  & ; ( ) < > space tab
control operator
              A token that performs a control function.  It is one of the following symbols:
              || & && ; ;; ( ) | <newline>


shell 转义符
*******************************

有时候，我们想让通配符，或者元字符变成普通字符，不需要使用它。那么这里我们就需要用到转义符了。 shell 提供转义符有三种。

============   =================
字符             说明
============   =================
‘’（单引号）      又叫硬转义，其内部所有的 shell 元字符、通配符都会被关掉。注意：硬转义中不允许出现单引号。
“”（双引号）      又叫软转义，其内部只允许出现特定的 shell 元字符，如：$ 用于参数代换，` 用于命令代替
\（反斜杠）       又叫转义，去除紧跟其后的元字符或通配符的特殊意义。
============   =================

实例:

::

    [chengmo@localhost ~/shell]$ ls *.txt
    a.txt  b.txt

    [chengmo@localhost ~/shell]$ ls \*.txt
    ls: 无法访问 *.txt: 没有那个文件或目录

    [chengmo@localhost ~/shell]$ ls '*.txt'
    ls: 无法访问 *.txt: 没有那个文件或目录

    [chengmo@localhost ~/shell]$ ls 'a.txt'
    a.txt

可以看到，加入了转义符“*”已经失去了通配符意义了。

shell 解析脚本的过程
*******************************

看到上面说的这些，想必大家会问到这个问题是，有这么想特殊字符、通配符，那么 shell 在得到一条命令，到底会怎么样处理的呢？我们看下下面的图：

.. image:: ../images/wildcard.01.png

如果用双引号包括起来，shell 检测跳过了 1-4 步和 9-10 步，单引号包括起来，shell 检测就会跳过了 1-10 步。也就是说，双引号只经过参数扩展、命令代换和算术代换就可以送入执行步骤，而单引号转义符直接会被送入执行步骤。而且，无论是双引号转义符还是单引号转义符在执行的时候能够告诉各个命令自身内部是一体的，但是其本身在执行时是并不是命令中文本的一部分。
