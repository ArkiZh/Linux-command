链接
======================

在 Unix 世界里有两个 link（链接）的概念，一般称之为硬连接和软连接（或符号连接）。在看链接之前最好理解一下 ``inode`` 的概念。

硬链接
----------------------

硬链接是最初 Unix 创建链接的方式。每个文件默认会有一个硬链接，这个硬链接给予文件名字。当创建一个硬链接，就会为文件创建了一个额外的文件名。硬链接有两个重要局限性：

1. 硬链接不能链接不在同一系统的文件。也就是说硬链接不能链接与文件不在同一磁盘分区上的文件；

2. 硬链接不能链接目录。

一个硬链接和文件本身没有什么区别。当你列出一个包含硬链接的文件时，不会有特殊的链接指示说明。当一个硬链接被删除时，文件本身的内容仍然存在（也就是说，它所占的磁盘空间不会被重新分配），直到所有关联这个文件的硬链接都删掉。

这里顺便说一下目录文件的"链接数"。创建目录时，默认会生成两个目录项： ``.`` 和 ``..`` 。 ``.`` 等同于当前目录的"硬链接"； ``..`` 等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2加上它的子目录总数（含隐藏目录）。

软链接（或符号连接）
----------------------

创建软链接是为了克服硬链接的局限性。软链接是通过创建一个特殊类型的文件（指针）链接到文件或目录。就像是 Windows 的快捷方式，当然，符号链接早于 Windows 的快捷方式很多年。

创建一个软链接，对这个软链接进行操作相当于直接对链接文件进行操作。 例如，往一个软链接里复制文件，复制的文件会到链接文件中。有一个例外，当你删除一个软链接时，只是删除这个软链接，而不会删除链接文件。如果先删除了链接文件，这个软链接仍然存在，但是不指向任何文件。在这种情况下，这个链接被称为坏链接。当使用 ``ls`` 命令查看时，会高亮显示坏链接，比如说红色。

**链接的应用:** 想象这样一个情景，某个程序要求使用一个包含在名为 “foo” 文件中的共享资源，但是 “foo” 经常改变版本号。如果能在文件名中包含版本号，就可以知道使用的是哪个 “foo” 版本。但是这样又会出现一个新的问题，假如更新了 “foo” 版本，那么我们必须跟踪每个可能使用 “foo” 的程序使它更新文件名，那么每次更新 “foo” 版本后，都要重复上边的工作，这听起来让人很抓狂。

符号链接可以更好的解决这个问题。比如，我们安装了文件 “foo” 的 2.6 版本，它的文件名是 “foo-2.6”，然后创建一个叫做 “foo” 的符号链接，这个符号链接指向 “foo-2.6”。这意味着，当一个程序打开文件 “foo” 时，它实际上是打开文件 “foo-2.6”。这样，依赖于 “foo” 文件的程序能找到这个文件，并且我们能知道安装了哪个 “foo” 版本。当升级到 “foo-2.7” 版本时，仅更新指向新版本的符号链接就可以了。这不仅解决了版本升级问题，而且还允许在系统中保存两个不同的文件版本。这样如果 “foo-2.7” 有个错误，我们只需要再更新回原来的 “foo-2.6” 链接就可以。

使用 ln 命令创建链接
----------------------

如果仅仅只给出一个文件名，那么 ln 将在当前目录下产生这个文件的硬链接，也就是说，以该文件（的最后一个）名称等同的名字在当前目录里产生一个连接；如果最后一个参数是一个已存在的目录名，ln 将在那个目录里给每一个源文件用以与源文件相同的文件名产生连接；如果只给出两个文件名，ln 将产生源文件的连接。不论是硬连结或软链结都不会将原本的文件复制一份，只会占用非常少量的磁碟空间。

命令格式:

.. code-block:: none

    ln [OPTION]... [-T] TARGET LINK_NAME   (1st form)
    ln [OPTION]... TARGET                  (2nd form)
    ln [OPTION]... TARGET... DIRECTORY     (3rd form)
    ln [OPTION]... -t DIRECTORY TARGET...  (4th form)


必要选项：

======    ==============================    ================
 选项       长选项                            说明
======    ==============================    ================
-d         --directory                      允许超级用户尝试硬链接目录（注意：可能由于系统限制而失败，即使是超级用户）
-f         --force                          删除现有的目标文件
-i         --interactive                    在覆盖既有文件之前先询问
-L         --logical                        取消链接
-n         --no-dereference                 将 LINK_NAME 看做一个普通文件，如果它是一个指向目录的软链接
-P         --physical                       将硬链接直接链接到软链接
-s         --symbolic                       建立软链接，而非默认的硬连接
-t         --target-directory=DIRECTORY     指定创建链接的目录
-v         --verbose                        显示链接的名称
======    ==============================    ================

**实例**

创建一个硬链接:

.. code-block:: none

    [root@localhost test_ln]# ln /home/zhangy/test ./


创建一个软链接:

.. code-block:: none

    [root@localhost test_ln]# ln -s /home/zhangy/test ./


**删除软链接**

.. code-block:: none

    # 正确的删除方式（删除软链接，但不删除实际数据）

    rm -rf  ./test_ln

    # 错误的删除方式

    rm -rf ./test_ln/ (这样就会把原来test_chk下的内容删除)

