Shell 快捷键
####################################

我经常开玩笑说：Lnix 操作系统是为喜欢敲键盘的人设计的。其实用户在使用命令行时并不喜欢敲入太多文本，所以命令中会存在像 cp、ls、mv 和 rm 那么多缩写的命令名。事实上，命令行最大的目标之一就是减少操作（省事），用最少的击键次数执行最多的任务；另一个目标是尽量不要使用鼠标，不要让手在鼠标和键盘之间来回切换而浪费太多的时间。让我们来学习一下如何使用快捷键来迅速、高效的输入命令。

移动光标和复制粘贴
************************************

Bash 使用了一个名为 Readline 的库（供不同的应用程序共享使用的线程集合），来实现命令行编辑。例如：用箭头键来移动光标，此外还有许多特性。

.. note::

    **注意：** 下面一些按键组合（尤其使用 Alt 键的组合），可能会被 GUI 定义为执行其它的功能，在练习中有任何的问题都可以按下 Ctrl+c 来终止当前命令。

运行 shell
====================================

在命令的执行中，也可以执行一定的操作：

=========   ===========
按键           作用
=========   ===========
Ctrl+s        挂起终端（有点像卡住了，但输入的命令还会执行）
Ctrl+q        恢复挂起的终端（恢复输入状态，并输出挂起时执行的命令）
Ctrl+c        中断、终止前台作业
Ctrl+z        暂停执行的前台作业，并放入后台。可输入新命令
=========   ===========

移动光标
====================================

下表列出了在命令行中移动光标所使用的按键：

=========   ===========
按键          作用
=========   ===========
Ctrl+a       移动光标到行首
Ctrl+e       移动光标到行尾
Ctrl+xx      在行首和光标两个位置间进行切换（此处是两个"x"字符）
Ctrl+f       光标前移一个字符（和右箭头作用一样）
Ctrl+b       光标后移一个字符（和左箭头作用一样）
Alt+f        光标前移一个单词
Alt+b        光标后移一个单词
Ctrl+l       清空屏幕（和 clear 命令作用一样）
=========   ===========

修改文本
==================================

下表列出了在命令行中编辑字符所使用的按键：

=========   ===========
按键           作用
=========   ===========
Ctrl+d         删除光标处的字符
Ctrl+t         互换光标处和光标前面的字符位置
Alt+t          互换光标处和光标前面的单词位置
Alt+c          将光标处的字母转换成大写字母
Alt+l          从光标位置到行尾的字符全部转换成小写字母
Alt+u          从光标位置到行尾的字符全部转换成大写字母
=========   ===========

剪切和粘贴文本
==================================

Readline 的文档使用术语 killing 和 yanking 来指代我们平常所说的剪切和粘贴。剪切的本文存储在一个叫做剪切环（kill-ring）的缓冲区中。

==============   ===========
按键                作用
==============   ===========
Ctrl+h             剪切（删除）一个字符
Ctrl+k             剪切从光标处到行尾的文本
Ctrl+u             剪切从光标处到行首的文本
Alt+d              剪切从光标处到词尾的文本
Alt+Backspace      剪切从光标处到词头的文本（如果光标在一个单词的开头则剪切前一个单词）
Ctrl+y             粘贴文本到光标处
Alt+r              清空行（如果命令是从历史记录中复制来的，则会恢复到原始状态）
==============   ===========

.. note::

    元键（meta key）

    在 bash 帮助文档的“READLINE”部分可以查看 Readline 文档，在这里你将会看到元键（meta key）这个术语。它对应于现代键盘中的 A1t 键，不过也并不总是这样。

    回到混沌时代（PC 时代前，UMX 时代后），并不是每个人都有自己的计算机。当时的用户可能只有一台称为终端的设备。终端是一种通信设备，它包含一个文本显示屏、一个键盘以及一些用来显示文本字符和移动光标的电子器件。终端（通常通过辛行电缆）连接到一台大型计算机或者大型计算机通信网。它有很多不同的品牌，因此有不同的键盘和不同的显示特性集。由于它们至少都能识别 ASCII 码，因此软件开发者想要编写符合最低标准的可移植的应用程序。UMX 系统有一套非常巧妙的方法来处理这些终端以及它们不同的显示特性。因为 Readline 的开发者们不能确定是否存在一个专门的附加控制键，所以他们发明了一个“元键”。现代键盘上的 A1t 健相当于元键，如果你仍然在使用终端，则按下和释放 Esc 键和长按住 A1t 健的效果是相同的（对于Linux系统也是如此）。


Tab 自动补全
********************************

shell 减少用户输入的另一种做法是自动补全。当你敲入一个命令时，按下 Tab 键，会自动补全未输入的文本。假设在用户家目录下输入：

.. highlight:: none

::

    [me@linuxbox ~]$ ls
    Desktop   ls-output.txt   Pictures   Templates   Videos
    ...


试着输入下面的命令，但不要按下 Enter 键：

::

    [me@linuxbox ~]$ ls l


现在按下 Tab 键，自动补全文件名：

::

    [me@linuxbox ~]$ ls ls-output.txt


再来看另一个例子，当然，也不要按下 Enter 键:

::

    [me@linuxbox ~]$ ls D


按下 Tab 键:

::

    [me@linuxbox ~]$ ls D


没有补全，只会发出嘟嘟的警告声。因为"D"不止匹配到了一个文件名，要让自动补全生效，必须保证命令的唯一性。所以你需要继续输入：

::

    [me@linuxbox ~]$ ls Do


然后按下 Tab 键：

::

    [me@linuxbox ~]$ ls Documents


自动补全成功了。

上边的实例展示了路径名自动补全，这也是最常用的形式。自动补全也能对变量（如果字的开头是一个 ``$`` ）、用户名字（单词以 ``~`` 开始）、命令（如果单词是一行的第一个单词）和主机名（如果单词的开头是 ``@`` ）起作用。但是主机名自动补全只会补全包含在文件 ``/etc/hosts`` 中的主机名。

有一系列的控制和元键序列与自动补全相关联：

========   =========
按键          作用
========   =========
Alt+?         显示可能的自动补全列表（和按两次 tab 键作用一样）
Alt+*         插入所有可能的自动补全（当使用多个匹配项时，比较有效）
========   =========

.. note::

    可编程自动补全

    目前的 bash 版本有一个叫做“可编程自动补全”工具。可编程自动补全允许用户（更可能是系统发行版提供商）添加额外的自动补全规则。一般来说，这样做是为了支持特定的应用，例如，可以为一个命令的长选项，添加自动补齐。默认情况下，Ubuntu定义了一个相当大的规则集合。可编程自动补齐通过 shell 函数来实现的，shell 函数是一种小型的 shell 脚本，默认情况下，并不是所有的发行版本都包含它们，


使用历史命令
******************************

bash 维护着一个已经执行过的命令列表。这个命令列表被保存在用户家目录下的 ``.bash_history`` 文件中。这些历史命令非常有用，因为它可以减少你敲击键盘的次数，尤其是和命令行编辑联系起来时。

搜索历史命令
==============================

在任何时候，我们都可以浏览历史列表的内容：

::

    [me@linuxbox ~]$ history | less

在默认情况下，会存储最后的 500 个命令。假如你想在曾经用过的命令中，找出和 /usr/bin 这一目录相关的。可以这样做：

::

    [me@linuxbox ~]$ history | grep /usr/bin

如果在搜索结果之中有一行包含了下边的命令：

::

    88  ls -l /usr/bin > ls-output.txt

数字 "88" 是这个命令在历史列表中的行号。我们使用历史命令扩展（history expansion）的方式，来调用 "88" 行的命令：

::

    [me@linuxbox ~]$ !88

bash 会把 "!88" 扩展成为历史列表中 88 行的内容。bash 也支持以递增方式搜索历史记录。也就是说，当搜索历史记录时，随着输入字符数的增加，bash 会相应地改变搜索范围。按下 Ctrl+r 键，接着输入你要查找的内容，可以开始递增式的搜索。当找到要查找的内容时，按 Enter 键表示执行此命令，而按 Ctrl+j 将把搜索到的内容从历史记录列表中复制到当前命令行。当要查找下一个匹配项时（即向前搜索历史记录），再次按下 Ctrl+r 键。若要退出搜索，按下 Ctr+g 或者 Ctrl+c 即可。请看下面的例子。：

::

    [me@linuxbox ~]$

首先按下 Ctrl+r:

::

    (reverse-i-search)`':

提示符发生改变，显示我们正在执行反向递增搜索。搜索过程是"反向的"，是因为查找是从“现在”到过去的某个时间段的顺序来搜索。下一步，我们开始输入要查找的文本。在这个例子里是 "/usr/bin"：

::

    (reverse-i-search)`/usr/bin': ls -l /usr/bin > ls-output.txt

搜索到了我们需要的结果后，我们可以按下 Enter 键来执行这个命令，或者我们可以按下 Ctrl-j 复制这个命令到我们当前的命令行，来进一步编辑它。好了现在我们复制它，按下 Ctrl-j：

::

    [me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt


我们的 shell 提示符重新出现，命令行加载完毕！下表列出了一些手动操作历史记录的组合键：

==========   ==============
按键            作用
==========   ==============
Ctrl+p         移动到上一个历史条目（和上箭头键作用一样）
Ctrl+n         移动到下一个历史条目（和下箭头键作用一样）
Alt+<          移动到历史列表开头
Alt+>          移动到历史列表结尾（即当前命令行）
Ctrl+r         反向递增搜索（从当前命令行开始，向上递增搜索）
Alt+p          反向非递增搜索。输入要查找的字符串，然后按下 Enter 键执行搜索
Alt+n          向前非递增搜索
Ctrl+o         执行历史列表中的当前项，并移到下一个
              （如果想要把历史列表中的一系列命令重新执行一遍，这回很方便）
==========   ==============

历史记录扩展
===========================

通过使用 "!" 字符，shell 为历史列表提供了一个特殊的扩展功能。我们已经知道，一个感叹号再加上一个数字，可以把来自历史列表中的命令插入到命令行中。这里还有一些其它的展开特性：

==========   ==============
序列           行为
==========   ==============
!!             重复最后一个执行的命令（按下上箭头键和 enter 键会更容易些）
!number        重复历史列表中第 number 行的命令
!string        重复最近的以 string 字符串开头的命令
!?string       重复最近的包含这个字符串的命令
==========   ==============

应该谨慎地使用 "!string" 和 "!?string" 格式，除非你完全确信历史列表条目的内容。

在历史记录扩展中，还有许多可利用的特点，但是这个主题就太晦涩难懂了，你可以查看 bash 手册页的 HISTORY EXPANSION 部分详尽地了解更多。

.. note::

    脚本

    除了 bash 中的命令历史特性，许多 Linux 发行版都包含一个叫做脚本（script）的程序，它记录了整个 shell 会话，并且将会话保存在一个文件里面。这个命令的基本语法是：

    ::

        script [file]

    其中的 file 是指用来存储会话记录的文件名。如果没有指定文件名，默认使用文件 typescript。脚本的 man 页面给出了该程序的所有选项和特性。

拓展阅读
**************************

Wikipedia 上有一篇关于计算机终端的好文章：http://en.wikipedia.org/wiki/Computer_terminal
